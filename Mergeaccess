import sys
import os
import pandas as pd
import time
from PyQt6.QtWidgets import (QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, 
                           QWidget, QPushButton, QLabel, QTextEdit, QFileDialog,
                           QDialog, QFormLayout, QComboBox, QDialogButtonBox,
                           QScrollArea, QFrame, QGraphicsDropShadowEffect)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer
from PyQt6.QtGui import QFont, QPalette, QColor, QPainter, QPen


class ProgressThread(QThread):
    """Thread for showing progress dots during calculations"""
    progress_signal = pyqtSignal(str)
    finished_signal = pyqtSignal()
    
    def __init__(self, message, duration=3):
        super().__init__()
        self.message = message
        self.duration = duration
        self.running = True
        
    def run(self):
        dots = ""
        start_time = time.time()
        
        while self.running and (time.time() - start_time) < self.duration:
            for i in range(4):  # 0 to 3 dots
                if not self.running:
                    break
                dots = "." * i
                self.progress_signal.emit(f"{self.message}{dots}")
                self.msleep(500)  # Wait 500ms
                
        self.finished_signal.emit()
    
    def stop(self):
        self.running = False


class PreloadThread(QThread):
    """Thread for preloading data without blocking UI"""
    log_signal = pyqtSignal(str, str)  # message, level
    progress_signal = pyqtSignal(str, bool)  # message, start_animation
    finished_signal = pyqtSignal(bool, str)  # success, message
    dataframe_loaded = pyqtSignal(str, object)  # filename, dataframe
    
    def __init__(self, excel_path, parent_dir):
        super().__init__()
        self.excel_path = excel_path
        self.parent_dir = parent_dir
        self.running = True
        
    def run(self):
        try:
            # Start progress animation for Excel reading
            self.progress_signal.emit("📖 Reading mapping Excel file", True)
            
            # Read the Excel file (this can take time for large files)
            xl_file = pd.ExcelFile(self.excel_path)
            sheet_names = xl_file.sheet_names
            
            # Stop progress animation and log completion
            self.progress_signal.emit("", False)
            self.log_signal.emit(f"📋 Found sheets: {', '.join(sheet_names)}", "INFO")
            
            # Start progress for reading sheet data
            self.progress_signal.emit("📊 Loading mapping data from sheet", True)
            
            # Read the mapping data (this can also take time)
            mapping_df = pd.read_excel(self.excel_path, sheet_name=0)
            
            # Stop progress and log completion
            self.progress_signal.emit("", False)
            self.log_signal.emit(f"📊 Loaded {len(mapping_df)} rows from mapping sheet", "SUCCESS")
            
            # Process each row in mapping
            for index, row in mapping_df.iterrows():
                if not self.running:
                    break
                    
                filename = str(row.get('filename', 'unknown'))
                filepath = str(row.get('path', ''))
                expected_columns = str(row.get('expected_columns', ''))
                
                # Construct full path
                if filepath:
                    full_path = os.path.join(self.parent_dir, filepath, filename)
                else:
                    full_path = os.path.join(self.parent_dir, filename)
                
                self.log_signal.emit(f"🔍 Looking for {filename} in {filepath if filepath else 'root'}......", "INFO")
                
                if os.path.exists(full_path):
                    self.log_signal.emit(f"✅ Found: {filename}", "SUCCESS")
                    
                    # Start progress animation for file processing
                    self.progress_signal.emit(f"⚙️ Reading {filename}", True)
                    
                    # Simulate reading the data file (this is where pd.read_excel/csv would go)
                    try:
                        # Determine file type and read accordingly
                        file_ext = os.path.splitext(filename)[1].lower()
                        
                        if file_ext in ['.xlsx', '.xls']:
                            # This is where the actual pd.read_excel() call would happen
                            # The progress animation will show while this executes
                            data_df = pd.read_excel(full_path)
                        elif file_ext == '.csv':
                            # This is where pd.read_csv() would happen
                            data_df = pd.read_csv(full_path)
                        else:
                            # For other file types, simulate reading
                            self.msleep(2000)  # Simulate time for reading
                            data_df = pd.DataFrame()  # Empty dataframe for demo
                        
                        # Stop progress animation
                        self.progress_signal.emit("", False)
                        self.log_signal.emit(f"✅ Successfully read {filename} ({len(data_df)} rows)", "SUCCESS")
                        
                        # Emit signal to save dataframe to appropriate variable
                        self.dataframe_loaded.emit(filename, data_df)
                        
                        # Column validation with progress
                        if expected_columns and not data_df.empty:
                            self.progress_signal.emit(f"🔍 Validating columns for {filename}", True)
                            
                            expected_cols = [col.strip() for col in expected_columns.split(',')]
                            actual_cols = data_df.columns.tolist()
                            
                            # Simulate validation time
                            self.msleep(1000)
                            
                            self.progress_signal.emit("", False)
                            
                            missing_cols = set(expected_cols) - set(actual_cols)
                            if missing_cols:
                                self.log_signal.emit(f"⚠️ Missing columns in {filename}: {', '.join(missing_cols)}", "WARNING")
                            else:
                                self.log_signal.emit(f"✅ All expected columns found in {filename}", "SUCCESS")
                                
                    except Exception as file_error:
                        self.progress_signal.emit("", False)
                        self.log_signal.emit(f"❌ Error reading {filename}: {str(file_error)}", "ERROR")
                        
                else:
                    self.log_signal.emit(f"❌ File not found: {full_path}", "ERROR")
                
                # Small delay between files
                self.msleep(300)
                
                # Check if we should continue
                if not self.running:
                    break
            
            self.finished_signal.emit(True, "Preload completed successfully")
            
        except Exception as e:
            self.progress_signal.emit("", False)  # Stop any running animation
            self.finished_signal.emit(False, f"Error during preload: {str(e)}")
    
    def stop(self):
        self.running = False


class MaterialButton(QPushButton):
    """Material Design styled button with custom color theme"""
    
    def __init__(self, text, color="#4A90E2", hover_color="#357ABD", text_color="white"):
        super().__init__(text)
        self.base_color = color
        self.hover_color = hover_color
        self.text_color = text_color
        self.setup_style()
        self.add_shadow()
        
    def setup_style(self):
        self.setStyleSheet(f"""
            QPushButton {{
                background-color: {self.base_color};
                color: {self.text_color};
                border: none;
                border-radius: 8px;
                padding: 12px 24px;
                font-size: 14px;
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }}
            QPushButton:hover {{
                background-color: {self.hover_color};
            }}
            QPushButton:pressed {{
                background-color: {self.hover_color};
                padding: 13px 23px 11px 25px;
            }}
            QPushButton:disabled {{
                background-color: #9E9E9E;
                color: #FFFFFF;
            }}
        """)
        
    def add_shadow(self):
        shadow = QGraphicsDropShadowEffect()
        shadow.setBlurRadius(12)
        shadow.setXOffset(0)
        shadow.setYOffset(4)
        shadow.setColor(QColor(0, 0, 0, 40))
        self.setGraphicsEffect(shadow)


class MaterialCard(QFrame):
    """Material Design card widget with custom theme"""
    
    def __init__(self):
        super().__init__()
        self.setFrameStyle(QFrame.Shape.NoFrame)
        self.setStyleSheet("""
            QFrame {
                background-color: #FEFEFE;
                border-radius: 12px;
                margin: 8px;
                border: 1px solid #E5E5E5;
            }
        """)
        self.add_shadow()
        
    def add_shadow(self):
        shadow = QGraphicsDropShadowEffect()
        shadow.setBlurRadius(15)
        shadow.setXOffset(0)
        shadow.setYOffset(3)
        shadow.setColor(QColor(0, 0, 0, 12))
        self.setGraphicsEffect(shadow)


class MissingElementsDialog(QDialog):
    def __init__(self, missing_elements, dropdown_options, parent=None):
        super().__init__(parent)
        self.missing_elements = missing_elements
        self.dropdown_options = dropdown_options
        self.element_mappings = {}
        self.setup_ui()
        
    def setup_ui(self):
        self.setWindowTitle("Map Missing Elements")
        self.setModal(True)
        self.setMinimumWidth(500)
        self.setMinimumHeight(400)
        
        # Apply custom material theme to dialog
        self.setStyleSheet("""
            QDialog {
                background-color: #F8F9FA;
            }
            QLabel {
                color: #3E2723;
                font-size: 14px;
            }
            QComboBox {
                background-color: #FEFEFE;
                border: 2px solid #D4B896;
                border-radius: 8px;
                padding: 12px;
                font-size: 14px;
                min-height: 20px;
                color: #3E2723;
            }
            QComboBox:focus {
                border-color: #4A90E2;
            }
            QComboBox::drop-down {
                border: none;
                width: 30px;
            }
            QComboBox::down-arrow {
                image: none;
                border-left: 5px solid transparent;
                border-right: 5px solid transparent;
                border-top: 5px solid #8D6E63;
                margin-right: 10px;
            }
            QComboBox QAbstractItemView {
                background-color: #FEFEFE;
                border: 1px solid #D4B896;
                selection-background-color: #E3F2FD;
                color: #3E2723;
            }
        """)
        
        layout = QVBoxLayout()
        layout.setSpacing(24)
        layout.setContentsMargins(32, 32, 32, 32)
        
        # Title
        title_label = QLabel("Map Missing Elements")
        title_label.setFont(QFont("Segoe UI", 24, QFont.Weight.Normal))
        title_label.setStyleSheet("color: #3E2723; margin-bottom: 8px;")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(title_label)
        
        subtitle_label = QLabel("Select the corresponding values for each missing element")
        subtitle_label.setFont(QFont("Segoe UI", 14))
        subtitle_label.setStyleSheet("color: #8D6E63; margin-bottom: 24px;")
        subtitle_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(subtitle_label)
        
        # Card for form content
        card = MaterialCard()
        card_layout = QVBoxLayout(card)
        card_layout.setContentsMargins(24, 24, 24, 24)
        
        # Form layout
        form_widget = QWidget()
        form_layout = QFormLayout(form_widget)
        form_layout.setSpacing(16)
        
        # Create dropdown for each missing element
        self.dropdowns = {}
        for element in self.missing_elements:
            # Element label
            element_label = QLabel(f"{element.title()}:")
            element_label.setFont(QFont("Segoe UI", 14, QFont.Weight.Medium))
            element_label.setStyleSheet("color: #5D4037; margin-bottom: 4px;")
            
            # Dropdown
            combo = QComboBox()
            combo.addItems(self.dropdown_options)
            combo.setCurrentIndex(0)
            self.dropdowns[element] = combo
            
            form_layout.addRow(element_label, combo)
            
        card_layout.addWidget(form_widget)
        layout.addWidget(card)
        
        # Buttons
        buttons_layout = QHBoxLayout()
        buttons_layout.setSpacing(16)
        
        cancel_btn = MaterialButton("Cancel", color="#9E9E9E", hover_color="#757575")
        cancel_btn.clicked.connect(self.reject)
        
        ok_btn = MaterialButton("Apply Mapping", color="#8D6E63", hover_color="#6D4C41")
        ok_btn.clicked.connect(self.accept)
        
        buttons_layout.addStretch()
        buttons_layout.addWidget(cancel_btn)
        buttons_layout.addWidget(ok_btn)
        
        layout.addLayout(buttons_layout)
        self.setLayout(layout)
    
    def get_mappings(self):
        """Return the element-value mappings"""
        mappings = {}
        for element, combo in self.dropdowns.items():
            mappings[element] = combo.currentText()
        return mappings


class ToolMainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.selected_path = ""
        self.main_df = pd.DataFrame()
        
        # Six dataframe variables for the six files
        self.df_file1 = pd.DataFrame()
        self.df_file2 = pd.DataFrame()
        self.df_file3 = pd.DataFrame()
        self.df_file4 = pd.DataFrame()
        self.df_file5 = pd.DataFrame()
        self.df_file6 = pd.DataFrame()
        
        # Dictionary to map filenames to dataframe variables
        self.filename_to_df_mapping = {
            # This will be populated dynamically based on your file naming convention
            # Example mappings - you can customize these based on your actual filenames
        }
        
        self.preload_thread = None
        self.progress_thread = None
        self.current_progress_line = None
        self.setup_ui()
        self.apply_custom_theme()
        
    def setup_ui(self):
        self.setWindowTitle("Data Processing Tool")
        self.setGeometry(100, 100, 1000, 700)
        self.setMinimumSize(800, 600)
        
        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Main layout
        main_layout = QVBoxLayout(central_widget)
        main_layout.setSpacing(0)
        main_layout.setContentsMargins(0, 0, 0, 0)
        
        # Header section
        self.create_header(main_layout)
        
        # Content area
        content_widget = QWidget()
        content_layout = QVBoxLayout(content_widget)
        content_layout.setContentsMargins(24, 24, 24, 24)
        content_layout.setSpacing(24)
        
        # Path selection section
        self.create_path_section(content_layout)
        
        # Buttons section
        self.create_buttons_section(content_layout)
        
        # Console section
        self.create_console_section(content_layout)
        
        main_layout.addWidget(content_widget)
        
    def apply_custom_theme(self):
        """Apply custom color scheme with sky blue, yellowish brown, brown, grey"""
        self.setStyleSheet("""
            QMainWindow {
                background-color: #F8F9FA;
            }
            QWidget {
                background-color: #F8F9FA;
                color: #3E2723;
                font-family: 'Segoe UI', sans-serif;
            }
        """)
        
    def create_header(self, parent_layout):
        """Create custom themed header"""
        header_frame = QFrame()
        header_frame.setFixedHeight(80)
        header_frame.setStyleSheet("""
            QFrame {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #4A90E2, stop:0.7 #87CEEB, stop:1 #B0E0E6);
                border: none;
            }
        """)
        
        # Add shadow to header
        shadow = QGraphicsDropShadowEffect()
        shadow.setBlurRadius(10)
        shadow.setXOffset(0)
        shadow.setYOffset(3)
        shadow.setColor(QColor(0, 0, 0, 25))
        header_frame.setGraphicsEffect(shadow)
        
        header_layout = QHBoxLayout(header_frame)
        header_layout.setContentsMargins(32, 0, 32, 0)
        
        title_label = QLabel("Data Processing Tool")
        title_label.setFont(QFont("Segoe UI", 28, QFont.Weight.Light))
        title_label.setStyleSheet("QLabel { color: white; }")
        
        subtitle_label = QLabel("Advanced data analysis and processing")
        subtitle_label.setFont(QFont("Segoe UI", 14))
        subtitle_label.setStyleSheet("QLabel { color: rgba(255, 255, 255, 0.9); }")
        
        title_layout = QVBoxLayout()
        title_layout.addWidget(title_label)
        title_layout.addWidget(subtitle_label)
        title_layout.setSpacing(4)
        
        header_layout.addLayout(title_layout)
        header_layout.addStretch()
        
        parent_layout.addWidget(header_frame)
        
    def create_path_section(self, parent_layout):
        """Create file selection section with custom theme"""
        # Section title
        section_title = QLabel("Excel Mapping File Selection")
        section_title.setFont(QFont("Segoe UI", 18, QFont.Weight.Medium))
        section_title.setStyleSheet("color: #5D4037; margin-bottom: 8px;")
        parent_layout.addWidget(section_title)
        
        # Path card
        path_card = MaterialCard()
        path_layout = QHBoxLayout(path_card)
        path_layout.setContentsMargins(24, 20, 24, 20)
        path_layout.setSpacing(16)
        
        # Browse button
        self.browse_button = MaterialButton("Browse Excel", color="#D4B896", hover_color="#BCAA83", text_color="#3E2723")
        self.browse_button.clicked.connect(self.browse_file)
        self.browse_button.setFixedWidth(160)
        
        # Path label
        self.path_label = QLabel("No mapping Excel file selected")
        self.path_label.setStyleSheet("""
            QLabel {
                background-color: #F5F5F5;
                border: 2px solid #E0E0E0;
                border-radius: 8px;
                padding: 12px 16px;
                font-size: 14px;
                color: #8D6E63;
            }
        """)
        self.path_label.setMinimumHeight(20)
        
        path_layout.addWidget(self.browse_button)
        path_layout.addWidget(self.path_label, 1)
        
        parent_layout.addWidget(path_card)
        
    def create_buttons_section(self, parent_layout):
        """Create action buttons with custom color scheme"""
        section_title = QLabel("Actions")
        section_title.setFont(QFont("Segoe UI", 18, QFont.Weight.Medium))
        section_title.setStyleSheet("color: #5D4037; margin-bottom: 8px;")
        parent_layout.addWidget(section_title)
        
        buttons_card = MaterialCard()
        buttons_layout = QHBoxLayout(buttons_card)
        buttons_layout.setContentsMargins(24, 20, 24, 20)
        buttons_layout.setSpacing(16)
        
        # Custom color scheme for buttons
        button_configs = [
            ("Pre-load", "#8D6E63", "#6D4C41"),      # Brown
            ("Access Logic", "#4A90E2", "#357ABD"),   # Sky Blue
            ("Control Check", "#A1887F", "#8D6E63"),  # Light Brown
            ("Response", "#6D4C41", "#5D4037"),       # Dark Brown
            ("Scorecard", "#9E9E9E", "#757575")       # Grey
        ]
        
        self.action_buttons = {}
        
        for name, color, hover_color in button_configs:
            button = MaterialButton(name, color=color, hover_color=hover_color)
            button.setMinimumHeight(48)
            
            # Connect buttons to handlers
            if name == "Pre-load":
                button.clicked.connect(self.preload_clicked)
            elif name == "Access Logic":
                button.clicked.connect(self.access_logic_clicked)
            else:
                button.clicked.connect(lambda checked, btn_name=name: self.log_message(f"{btn_name} button clicked"))
                
            self.action_buttons[name] = button
            buttons_layout.addWidget(button)
            
        parent_layout.addWidget(buttons_card)
        
    def create_console_section(self, parent_layout):
        """Create console section with custom theme"""
        section_title = QLabel("Console Output")
        section_title.setFont(QFont("Segoe UI", 18, QFont.Weight.Medium))
        section_title.setStyleSheet("color: #5D4037; margin-bottom: 8px;")
        parent_layout.addWidget(section_title)
        
        console_card = MaterialCard()
        console_layout = QVBoxLayout(console_card)
        console_layout.setContentsMargins(0, 0, 0, 0)
        
        self.console = QTextEdit()
        self.console.setStyleSheet("""
            QTextEdit {
                background-color: #2F2F2F;
                color: #4A90E2;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 12px;
                border: none;
                border-radius: 12px;
                padding: 16px;
                line-height: 1.4;
            }
            QScrollBar:vertical {
                background-color: #404040;
                width: 12px;
                border-radius: 6px;
            }
            QScrollBar::handle:vertical {
                background-color: #8D6E63;
                border-radius: 6px;
                min-height: 20px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #A1887F;
            }
        """)
        self.console.setReadOnly(True)
        self.console.setMinimumHeight(200)
        
        console_layout.addWidget(self.console)
        parent_layout.addWidget(console_card)
        
        # Log initial message
        self.log_message("🚀 Tool initialized. Ready for use.", "SUCCESS")
        self.log_message("📋 Expected Excel format: 'filename', 'path', 'expected_columns' columns", "INFO")
        
    def browse_file(self):
        """Handle Excel file browsing"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Excel Mapping File",
            "",
            "Excel Files (*.xlsx *.xls);;All Files (*)"
        )
        
        if file_path:
            self.selected_path = file_path
            self.path_label.setText(file_path)
            self.path_label.setStyleSheet("""
                QLabel {
                    background-color: #E8F4FD;
                    border: 2px solid #4A90E2;
                    border-radius: 8px;
                    padding: 12px 16px;
                    font-size: 14px;
                    color: #1565C0;
                    font-weight: 500;
                }
            """)
            self.log_message(f"📊 Excel mapping file selected: {os.path.basename(file_path)}", "SUCCESS")
            
    def preload_clicked(self):
        """Handle Pre-load button click"""
        self.log_message("🔄 Pre-load button clicked", "INFO")
        
        if not self.selected_path:
            self.log_message("❌ ERROR: No Excel mapping file selected. Please select an Excel file first.", "ERROR")
            return
            
        if not os.path.exists(self.selected_path):
            self.log_message("❌ ERROR: Selected Excel file does not exist.", "ERROR")
            return
            
        # Disable preload button during processing
        self.action_buttons["Pre-load"].setEnabled(False)
        
        # Get parent directory of Excel file
        parent_dir = os.path.dirname(self.selected_path)
        self.log_message(f"📁 Using parent directory: {parent_dir}", "INFO")
        
        # Start preload thread
        self.preload_thread = PreloadThread(self.selected_path, parent_dir)
        self.preload_thread.log_signal.connect(self.log_message)
        self.preload_thread.progress_signal.connect(self.show_progress)
        self.preload_thread.finished_signal.connect(self.preload_finished)
        self.preload_thread.dataframe_loaded.connect(self.store_dataframe)
        self.preload_thread.start()
    
    def store_dataframe(self, filename, dataframe):
        """Store dataframe in appropriate variable based on filename"""
        # Get base filename without extension
        base_filename = os.path.splitext(filename)[0].lower()
        
        # Define your mapping logic here based on your actual filenames
        # You can customize this mapping based on your specific file naming convention
        if 'file1' in base_filename or 'data1' in base_filename or 'first' in base_filename:
            self.df_file1 = dataframe
            df_name = "df_file1"
        elif 'file2' in base_filename or 'data2' in base_filename or 'second' in base_filename:
            self.df_file2 = dataframe
            df_name = "df_file2"
        elif 'file3' in base_filename or 'data3' in base_filename or 'third' in base_filename:
            self.df_file3 = dataframe
            df_name = "df_file3"
        elif 'file4' in base_filename or 'data4' in base_filename or 'fourth' in base_filename:
            self.df_file4 = dataframe
            df_name = "df_file4"
        elif 'file5' in base_filename or 'data5' in base_filename or 'fifth' in base_filename:
            self.df_file5 = dataframe
            df_name = "df_file5"
        elif 'file6' in base_filename or 'data6' in base_filename or 'sixth' in base_filename:
            self.df_file6 = dataframe
            df_name = "df_file6"
        else:
            # If filename doesn't match any pattern, assign to first available slot
            if self.df_file1.empty:
                self.df_file1 = dataframe
                df_name = "df_file1"
            elif self.df_file2.empty:
                self.df_file2 = dataframe
                df_name = "df_file2"
            elif self.df_file3.empty:
                self.df_file3 = dataframe
                df_name = "df_file3"
            elif self.df_file4.empty:
                self.df_file4 = dataframe
                df_name = "df_file4"
            elif self.df_file5.empty:
                self.df_file5 = dataframe
                df_name = "df_file5"
            elif self.df_file6.empty:
                self.df_file6 = dataframe
                df_name = "df_file6"
            else:
                # All slots filled, log warning
                self.log_message(f"⚠️ All dataframe slots filled. Could not store {filename}", "WARNING")
                return
        
        self.log_message(f"💾 Stored {filename} data in {df_name} ({len(dataframe)} rows, {len(dataframe.columns)} columns)", "SUCCESS")
        
        # Update filename to dataframe mapping for future reference
        self.filename_to_df_mapping[filename] = df_name
    
    def get_dataframe_summary(self):
        """Get summary of all loaded dataframes"""
        summary_info = []
        dataframes = [
            ("df_file1", self.df_file1),
            ("df_file2", self.df_file2),
            ("df_file3", self.df_file3),
            ("df_file4", self.df_file4),
            ("df_file5", self.df_file5),
            ("df_file6", self.df_file6)
        ]
        
        for df_name, df in dataframes:
            if not df.empty:
                summary_info.append(f"{df_name}: {len(df)} rows, {len(df.columns)} cols")
            else:
                summary_info.append(f"{df_name}: Empty")
        
        return summary_info
        
    def show_progress(self, message, start_animation):
        """Show progress with animated dots"""
        if start_animation:
            # Start new progress animation
            if self.progress_thread and self.progress_thread.isRunning():
                self.progress_thread.stop()
                self.progress_thread.wait()
                
            # Remove previous progress line if exists
            if self.current_progress_line:
                # Move cursor to end and add new line
                cursor = self.console.textCursor()
                cursor.movePosition(cursor.MoveOperation.End)
                self.console.setTextCursor(cursor)
                
            # Start indefinite progress animation (no duration limit)
            self.progress_thread = ProgressThread(message, duration=999)  # Very long duration
            self.progress_thread.progress_signal.connect(self.update_progress_line)
            self.progress_thread.finished_signal.connect(self.progress_finished)
            self.progress_thread.start()
        else:
            # Stop current progress animation
            if self.progress_thread and self.progress_thread.isRunning():
                self.progress_thread.stop()
                self.progress_thread.wait()
                self.progress_finished()  # Clean up the progress line
        
    def update_progress_line(self, text):
        """Update the current progress line"""
        timestamp = pd.Timestamp.now().strftime("%H:%M:%S")
        color = "#D4B896"  # Yellowish brown for progress
        
        # Get current cursor position
        cursor = self.console.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        
        # If we have a current progress line, remove it
        if self.current_progress_line:
            cursor.movePosition(cursor.MoveOperation.StartOfLine)
            cursor.movePosition(cursor.MoveOperation.End, cursor.MoveMode.KeepAnchor)
            cursor.removeSelectedText()
        
        # Add the new progress text
        progress_html = f'<span style="color: #9E9E9E;">[{timestamp}]</span> <span style="color: {color};">{text}</span>'
        cursor.insertHtml(progress_html)
        
        self.current_progress_line = text
        
        # Auto-scroll to bottom
        self.console.verticalScrollBar().setValue(
            self.console.verticalScrollBar().maximum()
        )
        
    def progress_finished(self):
        """Called when progress animation finishes"""
        if self.current_progress_line:
            # Move to end and add a new line
            cursor = self.console.textCursor()
            cursor.movePosition(cursor.MoveOperation.End)
            cursor.insertText("\n")
            self.console.setTextCursor(cursor)
            self.current_progress_line = None
            
    def preload_finished(self, success, message):
        """Handle preload completion"""
        # Re-enable preload button
        self.action_buttons["Pre-load"].setEnabled(True)
        
        # Stop any running progress thread
        if self.progress_thread and self.progress_thread.isRunning():
            self.progress_thread.stop()
            self.progress_thread.wait()
            
        if success:
            self.log_message(f"✅ {message}", "SUCCESS")
            
            # Show summary of loaded dataframes
            summary = self.get_dataframe_summary()
            self.log_message("📊 Dataframe Summary:", "INFO")
            for info in summary:
                self.log_message(f"   • {info}", "INFO")
                
            # Show filename to dataframe mapping
            if self.filename_to_df_mapping:
                self.log_message("🗂️ File Mapping:", "INFO")
                for filename, df_name in self.filename_to_df_mapping.items():
                    self.log_message(f"   • {filename} → {df_name}", "INFO")
        else:
            self.log_message(f"❌ {message}", "ERROR")
            
    def access_logic_clicked(self):
        """Handle Access Logic button click"""
        self.log_message("🔍 Access Logic button clicked", "INFO")
        
        if not self.selected_path:
            self.log_message("❌ ERROR: No Excel mapping file selected. Please select an Excel file first.", "ERROR")
            return
            
        # Simulate checking for missing elements
        self.log_message("⏳ Analyzing mapping data for missing elements...", "INFO")
        
        # Example: simulate missing elements
        missing_elements = ["bhopal", "indore", "nagpur"]
        dropdown_options = ["MP", "MH", "KA", "RJ"]
        
        self.log_message(f"⚠️ Found missing elements: {', '.join(missing_elements)}", "WARNING")
        
        # Show dialog for mapping missing elements
        dialog = MissingElementsDialog(missing_elements, dropdown_options, self)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            mappings = dialog.get_mappings()
            self.log_message("✅ Element mappings received:", "SUCCESS")
            
            # Process the mappings and add to dataframe
            new_combinations = []
            for element, value in mappings.items():
                combination = f"{element}-{value}"
                new_combinations.append(combination)
                self.log_message(f"   • {element} → {value} (Combined: {combination})", "INFO")
            
            # Add combinations to dataframe
            self.add_combinations_to_df(new_combinations)
            
        else:
            self.log_message("❌ Element mapping cancelled by user", "WARNING")
    
    def add_combinations_to_df(self, combinations):
        """Add combinations to the main dataframe"""
        self.log_message("💾 Adding combinations to dataframe:", "INFO")
        
        # Create a dataframe with the combinations
        new_data = pd.DataFrame({"combinations": combinations})
        
        if self.main_df.empty:
            self.main_df = new_data
        else:
            self.main_df = pd.concat([self.main_df, new_data], ignore_index=True)
        
        self.log_message(f"📊 Dataframe updated. Total rows: {len(self.main_df)}", "SUCCESS")
        self.log_message("📋 Current combinations in dataframe:", "INFO")
        for combo in combinations:
            self.log_message(f"   • {combo}", "SUCCESS")
        
    def log_message(self, message, level="INFO"):
        """Add styled message to console with custom color scheme"""
        colors = {
            "INFO": "#4A90E2",        # Sky Blue
            "SUCCESS": "#8D6E63",     # Brown
            "WARNING": "#D4B896",     # Yellowish Brown
            "ERROR": "#A1887F"        # Light Brown
        }
        
        color = colors.get(level, "#4A90E2")
        timestamp = pd.Timestamp.now().strftime("%H:%M:%S")
        
        self.console.append(f'<span style="color: #9E9E9E;">[{timestamp}]</span> '
                          f'<span style="color: {color};">{message}</span>')
        
        # Auto-scroll to bottom
        self.console.verticalScrollBar().setValue(
            self.console.verticalScrollBar().maximum()
        )

    def closeEvent(self, event):
        """Handle application close event"""
        # Stop any running threads
        if self.preload_thread and self.preload_thread.isRunning():
            self.preload_thread.stop()
            self.preload_thread.wait()
            
        if self.progress_thread and self.progress_thread.isRunning():
            self.progress_thread.stop()
            self.progress_thread.wait()
            
        event.accept()


def main():
    app = QApplication(sys.argv)
    
    # Set application style
    app.setStyle('Fusion')
    
    # Set application-wide font
    font = QFont("Segoe UI", 10)
    app.setFont(font)
    
    window = ToolMainWindow()
    window.show()
    
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
