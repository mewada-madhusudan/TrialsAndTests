using ClosedXML.Excel;
using System;
using System.Collections.Concurrent;
using System.Text.RegularExpressions;

public class FormulaAnalyzer
{
    public class FormulaPattern
    {
        public string Sheet { get; set; }
        public string StartCell { get; set; }
        public string BaseFormula { get; set; }
        public string DragDirection { get; set; }
        public int SequenceLength { get; set; }
        public string LastCell { get; set; }
        public bool IsInPivotSheet { get; set; }
    }

    private readonly IProgress<string> _progress;
    private readonly ConcurrentBag<FormulaPattern> _patterns = new();

    public FormulaAnalyzer(IProgress<string> progress = null)
    {
        _progress = progress ?? new Progress<string>(msg => 
            Console.WriteLine($"{DateTime.Now:HH:mm:ss.fff}: {msg}"));
    }

    public void AnalyzeFormulas(string filePath)
    {
        LogProgress($"Starting analysis of {filePath}");
        
        using var workbook = new XLWorkbook(filePath);
        foreach (var worksheet in workbook.Worksheets)
        {
            ProcessWorksheet(worksheet);
        }
        
        ExportResults("formula_patterns.xlsx");
    }

    private void ProcessWorksheet(IXLWorksheet worksheet)
    {
        LogProgress($"Processing worksheet: {worksheet.Name}");
        var usedRange = worksheet.RangeUsed();
        if (usedRange == null) return;

        var formulaCells = usedRange.Cells()
            .Where(cell => cell.HasFormula)
            .ToList();

        var processedCells = new HashSet<string>();

        foreach (var cell in formulaCells)
        {
            if (processedCells.Contains(cell.Address.ToString()))
                continue;

            var pattern = DetectPattern(worksheet, cell);
            if (pattern != null)
            {
                _patterns.Add(pattern);
                // Add all cells in this pattern to processed cells
                var cells = GetCellsInPattern(pattern);
                foreach (var c in cells)
                    processedCells.Add(c);
            }
        }
    }

    private FormulaPattern DetectPattern(IXLWorksheet worksheet, IXLCell startCell)
    {
        var baseFormula = startCell.FormulaA1;
        var row = startCell.Address.RowNumber;
        var col = startCell.Address.ColumnNumber;

        // Check for row-wise pattern
        var rowPattern = CheckRowPattern(worksheet, row, col, baseFormula);
        if (rowPattern.Item1)
        {
            return new FormulaPattern
            {
                Sheet = worksheet.Name,
                StartCell = startCell.Address.ToString(),
                BaseFormula = baseFormula,
                DragDirection = "Row-wise",
                SequenceLength = rowPattern.Item2,
                LastCell = worksheet.Cell(row, col + rowPattern.Item2 - 1).Address.ToString(),
                IsInPivotSheet = worksheet.PivotTables.Any()
            };
        }

        // Check for column-wise pattern
        var colPattern = CheckColumnPattern(worksheet, row, col, baseFormula);
        if (colPattern.Item1)
        {
            return new FormulaPattern
            {
                Sheet = worksheet.Name,
                StartCell = startCell.Address.ToString(),
                BaseFormula = baseFormula,
                DragDirection = "Column-wise",
                SequenceLength = colPattern.Item2,
                LastCell = worksheet.Cell(row + colPattern.Item2 - 1, col).Address.ToString(),
                IsInPivotSheet = worksheet.PivotTables.Any()
            };
        }

        return null;
    }

    private (bool, int) CheckRowPattern(IXLWorksheet worksheet, int row, int col, string baseFormula)
    {
        int length = 1;
        while (true)
        {
            var nextCell = worksheet.Cell(row, col + length);
            if (!nextCell.HasFormula) break;

            var expectedFormula = IncrementFormulaColumns(baseFormula, length);
            if (nextCell.FormulaA1 != expectedFormula) break;

            length++;
        }
        return (length > 1, length);
    }

    private (bool, int) CheckColumnPattern(IXLWorksheet worksheet, int row, int col, string baseFormula)
    {
        int length = 1;
        while (true)
        {
            var nextCell = worksheet.Cell(row + length, col);
            if (!nextCell.HasFormula) break;

            var expectedFormula = IncrementFormulaRows(baseFormula, length);
            if (nextCell.FormulaA1 != expectedFormula) break;

            length++;
        }
        return (length > 1, length);
    }

    private string IncrementFormulaColumns(string formula, int increment)
    {
        return Regex.Replace(formula, @"([A-Z]+)(\d+)", match =>
        {
            var column = match.Groups[1].Value;
            var row = match.Groups[2].Value;
            var newCol = GetOffsetColumn(column, increment);
            return $"{newCol}{row}";
        });
    }

    private string IncrementFormulaRows(string formula, int increment)
    {
        return Regex.Replace(formula, @"([A-Z]+)(\d+)", match =>
        {
            var column = match.Groups[1].Value;
            var row = int.Parse(match.Groups[2].Value);
            return $"{column}{row + increment}";
        });
    }

    private string GetOffsetColumn(string column, int offset)
    {
        int colNum = 0;
        for (int i = 0; i < column.Length; i++)
        {
            colNum *= 26;
            colNum += column[i] - 'A' + 1;
        }
        colNum += offset;

        string result = "";
        while (colNum > 0)
        {
            colNum--;
            result = (char)('A' + (colNum % 26)) + result;
            colNum /= 26;
        }
        return result;
    }

    private List<string> GetCellsInPattern(FormulaPattern pattern)
    {
        var cells = new List<string>();
        var startAddress = new XLAddress(pattern.StartCell);
        var lastAddress = new XLAddress(pattern.LastCell);

        if (pattern.DragDirection == "Row-wise")
        {
            for (int col = startAddress.ColumnNumber; col <= lastAddress.ColumnNumber; col++)
            {
                cells.Add(XLHelper.GetColumnLetterFromNumber(col) + startAddress.RowNumber);
            }
        }
        else
        {
            for (int row = startAddress.RowNumber; row <= lastAddress.RowNumber; row++)
            {
                cells.Add(XLHelper.GetColumnLetterFromNumber(startAddress.ColumnNumber) + row);
            }
        }

        return cells;
    }

    private void ExportResults(string outputPath)
    {
        LogProgress("Creating output file...");
        using var workbook = new XLWorkbook();
        var sheet = workbook.AddWorksheet("Formula Patterns");

        // Add headers
        sheet.Cell("A1").Value = "Sheet";
        sheet.Cell("B1").Value = "Start Cell";
        sheet.Cell("C1").Value = "Base Formula";
        sheet.Cell("D1").Value = "Drag Direction";
        sheet.Cell("E1").Value = "Sequence Length";
        sheet.Cell("F1").Value = "Last Cell";
        sheet.Cell("G1").Value = "In Pivot Sheet";

        // Add data
        var row = 2;
        foreach (var pattern in _patterns.OrderBy(p => p.Sheet).ThenBy(p => p.StartCell))
        {
            sheet.Cell(row, 1).Value = pattern.Sheet;
            sheet.Cell(row, 2).Value = pattern.StartCell;
            sheet.Cell(row, 3).Value = pattern.BaseFormula;
            sheet.Cell(row, 4).Value = pattern.DragDirection;
            sheet.Cell(row, 5).Value = pattern.SequenceLength;
            sheet.Cell(row, 6).Value = pattern.LastCell;
            sheet.Cell(row, 7).Value = pattern.IsInPivotSheet;
            row++;
        }

        // Set column widths
        sheet.Columns().AdjustToContents();
        workbook.SaveAs(outputPath);
        LogProgress("Results exported successfully!");
    }

    private void LogProgress(string message)
    {
        _progress?.Report($"{DateTime.Now:HH:mm:ss.fff}: {message}");
    }
}
