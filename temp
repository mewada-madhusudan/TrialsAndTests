import pandas as pd
import sqlite3
from datetime import datetime
from typing import Union

def upsert_application_row(row: pd.Series, db_path: str) -> dict:
    """
    Upsert a single row into the applications table, handling auto-increment ID
    and timestamp columns automatically.
    
    Parameters:
    -----------
    row : pd.Series
        Single row from DataFrame containing application data
    db_path : str
        Path to the SQLite database file
        
    Returns:
    --------
    dict
        Summary of operation performed including the ID of the inserted/updated row
    """
    try:
        # Connect to database
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Get current timestamp
        current_timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        # Get the list of all columns in the row
        row_columns = set(row.index)
        
        # Prepare columns and values for the query
        # Exclude id (auto-increment) and timestamp columns from the input data
        data_columns = [col for col in row_columns 
                       if col not in ['id', 'created_at', 'updated_at', 'deleted_at']]
        
        if 'id' in row_columns and pd.notna(row['id']):
            # Update existing record
            set_clauses = [f"{col} = ?" for col in data_columns]
            set_clauses.append("updated_at = ?")
            
            query = f"""
                UPDATE applications 
                SET {', '.join(set_clauses)}
                WHERE id = ?
            """
            
            # Prepare values for update
            values = [row[col] for col in data_columns]
            values.append(current_timestamp)  # for updated_at
            values.append(row['id'])  # for WHERE clause
            
            cursor.execute(query, values)
            
            if cursor.rowcount == 0:
                # If no update occurred, insert as new record
                columns = data_columns + ['created_at', 'updated_at']
                placeholders = ', '.join(['?' for _ in columns])
                
                query = f"""
                    INSERT INTO applications ({', '.join(columns)})
                    VALUES ({placeholders})
                """
                
                values = [row[col] for col in data_columns]
                values.extend([current_timestamp, current_timestamp])  # for timestamps
                
                cursor.execute(query, values)
        else:
            # Insert new record
            columns = data_columns + ['created_at', 'updated_at']
            placeholders = ', '.join(['?' for _ in columns])
            
            query = f"""
                INSERT INTO applications ({', '.join(columns)})
                VALUES ({placeholders})
            """
            
            values = [row[col] for col in data_columns]
            values.extend([current_timestamp, current_timestamp])  # for timestamps
            
            cursor.execute(query, values)
        
        # Get the ID of the inserted/updated record
        row_id = cursor.lastrowid if cursor.lastrowid else row.get('id')
        
        # Commit and close
        conn.commit()
        conn.close()
        
        return {
            'status': 'success',
            'id': row_id,
            'message': f'Successfully upserted row with ID {row_id}'
        }
        
    except Exception as e:
        if 'conn' in locals():
            conn.close()
        return {
            'status': 'error',
            'id': None,
            'message': f'Error during upsert: {str(e)}'
        }

def get_application_by_id(db_path: str, app_id: int) -> Union[pd.Series, None]:
    """
    Retrieve an application record by its ID.
    
    Parameters:
    -----------
    db_path : str
        Path to the SQLite database file
    app_id : int
        ID of the application to retrieve
        
    Returns:
    --------
    pd.Series or None
        Application record if found, None otherwise
    """
    try:
        conn = sqlite3.connect(db_path)
        query = "SELECT * FROM applications WHERE id = ?"
        
        result = pd.read_sql_query(query, conn, params=[app_id])
        conn.close()
        
        return result.iloc[0] if not result.empty else None
        
    except Exception as e:
        if 'conn' in locals():
            conn.close()
        raise e
